#define _GNU_SOURCE
#include <stdio.h>

#include <fitz.h>
#include <mupdf.h>

#include "epdf_private.h"
#include "Epdf.h"

static void* pdfdoc_error(Epdf_Document* doc)
{
    if(doc)
        free(doc);

    return NULL;
}

Epdf_Document* epdf_document_new(const char* filename)
{
    Epdf_Document* doc;
    fz_error error;

    doc = (Epdf_Document*)malloc(sizeof(Epdf_Document));
    if(!doc)
        return NULL;

    doc->xref = NULL;
    doc->outline = NULL;
    doc->rast = NULL;
    doc->pagecount = 0;
    doc->zoom = 1.0;
    doc->rotate = 0;
    doc->locked = false;

    error = fz_newrenderer(&doc->rast, pdf_devicergb, 0, 1024 * 512);
    if(error)
        return pdfdoc_error(doc);

    fz_obj* obj;

    // Open PDF and load xref table

    error = pdf_newxref(&doc->xref);
    if(error)
        return pdfdoc_error(doc);

    error = pdf_loadxref(doc->xref, (char*)filename);
    if(error)
    {
        fz_catch(error, "trying to repair");
        fprintf(stderr, "There was a problem with file \"%s\".\nIt may be corrupted or generated by faulty software.\nTrying to repair the file.\n", filename);
        error = pdf_repairxref(doc->xref, (char*)filename);
        if(error)
            return pdfdoc_error(doc);
    }

    error = pdf_decryptxref(doc->xref);
    if(error)
        pdfdoc_error(doc);

    // Handle encrypted PDF files

    if(pdf_needspassword(doc->xref))
        doc->locked = true;

    /*
     * Load meta information
     * TODO: move this into mupdf library
     */

    obj = fz_dictgets(doc->xref->trailer, "Root");
    doc->xref->root = fz_resolveindirect(obj);
    if(!doc->xref->root)
    {
        fz_throw("syntaxerror: missing Root object");
        pdfdoc_error(doc);
    }
    fz_keepobj(doc->xref->root);

    obj = fz_dictgets(doc->xref->trailer, "Info");
    doc->xref->info = fz_resolveindirect(obj);
    if(!doc->xref->info)
        fprintf(stderr, "Could not load PDF meta information.\n");
    if(doc->xref->info)
        fz_keepobj(doc->xref->info);

    error = pdf_loadoutline(&doc->outline, doc->xref);
    if(error)
        pdfdoc_error(doc);

    doc->filename = strdup(filename);
    if(doc->xref->info)
    {
        obj = fz_dictgets(doc->xref->info, "Title");
        if(obj)
        {
            error = pdf_toutf8(&doc->doctitle, obj);
            if(error)
                doc->doctitle = NULL;
        }
    }

    /*
     * Start at first page
     */

    error = pdf_getpagecount(doc->xref, &doc->pagecount);
    if(error)
        pdfdoc_error(doc);

    if(doc->zoom < 0.1)
        doc->zoom = 0.1;
    if(doc->zoom > 3.0)
        doc->zoom = 3.0;

    return doc;
}

void epdf_document_delete(Epdf_Document* doc)
{
    if(!doc)
        return; 

    if(doc->outline)
    {
        pdf_dropoutline(doc->outline);
        doc->outline = NULL;
    }

    if(doc->xref->store)
    {
        pdf_dropstore(doc->xref->store);
        doc->xref->store = NULL;
    }

    pdf_closexref(doc->xref);
    doc->xref = NULL;

    if(doc->rast)
    {
        fz_droprenderer(doc->rast);
        doc->rast = NULL;
    }

    free(doc);
}

unsigned char epdf_document_is_locked(const Epdf_Document* doc)
{
    if(!doc)
        return 0;

    return doc->locked?1:0;
}

unsigned char epdf_document_unlock(Epdf_Document* doc, const char* password)
{
    if(!doc)
        return 0;

    if(doc->locked)
        if(!pdf_authenticatepassword(doc->xref, (char*)password))
            fprintf(stderr, "Invalid password.\n");
        else
            doc->locked = false;

    return doc->locked?1:0;
}

int epdf_document_page_count_get(const Epdf_Document* doc)
{
    if(!doc)
        return 0;

    return doc->pagecount;
}

static char* epdf_document_property_get(const Epdf_Document* doc, const char* property)
{
    fz_error error;
    fz_obj* obj;
    char* ret;

    if(doc->xref->info)
    {
        obj = fz_dictgets(doc->xref->info, property);
        if(obj)
        {
            if(pdf_toutf8(&ret, obj))
                return ret;
            else
                return fz_tostrbuf(obj);
        }
    }

    return NULL;
}

char* epdf_document_title_get(const Epdf_Document* doc)
{
    if(!doc)
        return NULL;

    return epdf_document_property_get(doc, "Title");
}

char* epdf_document_author_get(const Epdf_Document* doc)
{
    if(!doc)
        return NULL;

    return epdf_document_property_get(doc, "Author");
}

char* epdf_document_subject_get(const Epdf_Document* doc)
{
    if(!doc)
        return NULL;

    return epdf_document_property_get(doc, "Subject");
}

char* epdf_document_keywords_get(const Epdf_Document* doc)
{
    if(!doc)
        return NULL;

    return epdf_document_property_get(doc, "Keywords");
}

char* epdf_document_creator_get(const Epdf_Document* doc)
{
    if(!doc)
        return NULL;

    return epdf_document_property_get(doc, "Creator");
}

char* epdf_document_producer_get(const Epdf_Document* doc)
{
    if(!doc)
        return NULL;

    return epdf_document_property_get(doc, "Producer");
}

static char* epdf_document_date_get(const Epdf_Document* doc, const char* type)
{
    fz_error error;
    fz_obj* obj;

    if(doc->xref->info)
    {
        obj = fz_dictgets(doc->xref->info, type);
        if(obj)
        {
            int year, month, day, hour, minute, second;
            char* date = fz_tostrbuf(obj);
            if(date[0] == 'D')
                date += 2;
            sscanf(date, "%4d%2d%2d%2d%2d%2d", &year, &month, &day, &hour, &minute, &second);
            asprintf(&date, "%d-%02d-%02d %02d:%02d:%02d", year, month, day, hour, minute, second);

            return date;
        }
    }

    return NULL;
}

char* epdf_document_creation_date_get(const Epdf_Document* doc)
{
    if(!doc)
        return NULL;

    return epdf_document_date_get(doc, "CreationDate");
}

char* epdf_document_mod_date_get(const Epdf_Document* doc)
{
    if(!doc)
        return NULL;

    return epdf_document_date_get(doc, "ModDate");
}
